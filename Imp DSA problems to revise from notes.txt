Foundation 1
----------------

Arrays
--------

1) Bar Chart....best pattern question
2) Subsets of Array
3) Ceil and Floor......Application of binary search
4) First Index, Last Index......Application of binary search


2D Arrays
------------

1) Spiral Traversal....box k andar box se solve kro, innermost box might not have all walls
2) Rotate Matrix by 90 degree clockwise.......... Transpose me [i][j] ko [j][i] se swap karna hota h but this cannot be done for all i,j combinations.....only for half of total combinations...in which j>=i
3) Search in a sorted 2D array


Strings, String Builders, ArrayLists
------------------------------------------

1) Print all substrings
2) Print all palindromic substrings..........Brute force
3) String compression
4) Print all permutations of a string - iterative (Not at all intuitive).....divide by n then (n-1)....all the way to 1...divide kya? kaunsawa permutation and the subsequent quotients....jo jo remainder aate jata h remaining string me se usko nikalkar print krte rho
5) Remove primes from arraylist..........Conclusion: always remove elements from end of arraylist....taki shifting (due to deletion from mid arraylist) k wajah se garbar na ho jaye


Recursion
------------

1) Tower of Hanoi
2) First Index, Last Index in array (Iterative wale me binary search use kar skte...see above in this text file under Arrays section)
3) All indices of array..........DIY without seeing solution
4) Get Subsequence
5) Get KeyPad Combination.......DIY if revised 4
6) Get Stair Paiths....ek ek karke hi sirf to decrement nhi kar rhe  ==> n can become < 0 too in just 1 step
7) Get Maze Path with Jumps..........DIY without seeing solution
8) Print Subsequence............ on way up...ans bnate chalo.....compare with "Get Subsequence" which is "on way down" soln
9) Print stair paths.....path + 1 krne se kya hoga aur 1+ path krne se kya hoga ye socho
10) Print Maze paths....notice the two ways...call smart, base case normal ......call stupid, base case smart.....bas ye call krne ka tareeka revise krwana tha notes me se....waise to question me dam nhi
11) Print permutations...sare characters ko starting character banne ka mauka dena hoga.......compare with "Print all permutations of a string - iterative" under Strings section
12) Print Encodings......DIY.........2 options - 1char, 2 char ko parse karna h sari possibilities bnane k liye .....2 char hona bhi chahiye pehle....aur wo bhi 2char >26 nhi hona chahiye
13) FloodFill...backtracking ka matlab apne footprints mita dena....par aisa krna hi kyu h? .....ya to previously exploration me ans nhi mila ya phir mil gya and aur bhi mil sakta h cuz multiple ans are possible.....understand visited array ka significance ...needed when we go in dir and 180 degree opposite dir as well..to prevent infinite loop visited array lena padta h.....understand why Red Euro symbol k jagah par return likhna kyu required h

By now I am wondering kab kab "on way up" use karna h aur kab "on way down"....kahin to notes me likha tha ye shayd...maybe level up k recursion ya DP me mil jaye.....TODO: mile to yahan likh dena reason

for now --> man me socho jisme recursiveAns se myAns bnana hard lge...usme "on way down" nhi use krna

14) Target Sum Subsets.....pehle subsets bna lo phir target se subsetSum compare kro.........baad me jab poora subset bn gya h tab jakar loop lgakar sum calculate krne se accha h ki jaise jaise "on way up" jate ho waise waise subsetSum calculate krte rho
15) N Queens.....Very Very Imp.....how solution thought from scratch all the way to its code
16) Knights Tour


Stacks and Queues
-----------------------

1) Read from OOPS | Swap Game 3 onwards to just before start of Arrays and Queues section
2) Dynamic stack...using array.....create array of double size, change reference..........seems O(n) due to copying all elements of old array into new one...but push() even now is O(1)......dynamic me kabhi overflow msg print krne ki zaroort nhi pdti (same with dynamic queue as well.....front pointer humesha update krte hue chalna h)....tos pointer humesha update krte hue chalna h

Queue<> ke aur Stack<> ke alag alag se functions yaad rkhne se accha h always use ArrsyList<> as stack or queue a/c to need

Stack<> --> push(), pop()
Queue<> --> add(), remove()

3) Normal Queue
4) Balanced Brackets....3 cases should be dealt #OB> #CB or #OB < #CB or inappropriate pair(jo bracket sabse baad me aaya h(open hua h) wo sabse pehle close honi chahiye)  
5) Duplicate Brackets....meaning of duplicate brackets smjhna is tricky.........we don't talk about duplicate brackets if the given expression is not balanced (Balanced Brackets).......when CB is encountered pop till OB............. agar CB se just pehle OB hi mil jaye ( no characters in between) ==> duplicate brackets
6) Celebrity Problem.....Very Imp....question padhkar bilkul nhi lagta ki ye stack problem ho sakta h...aur stack se kaise solve kar skte wo bhi itna zyada intuitive nhi..............Approach --> all possible celebrities ko stack me store rkho (initially sare k sare ko possible celebrity maankar stack me rakh do).... then 2 do krke pop kro aur ek possibly celebrity ko filter out kar do........ ye repeated filtering out tab tak krni h jab tak stack me bas 1 possible celebrity nhi reh jata....jo reh gya h wo bhi possible celebrity h confirm celebrity nhi ( there can be either 0 celebrity or only 1 celebrity...kind of like Saddle Point under 2D Arrays section)...to ab is possible celebrity par celebrity h ya nhi ka check phir lga do ......ye stack solution ka TC O(n) kaise h ye smjhna bhi zaroori h
7) Postfix Evaluation and Conversion....Imp type
8) Infix evaluation .....Very Imp.....Interview me ye 100 % shi ho jaye matlab tum alag hi level pe ho

   - 2 stacks used 1) for operands 2) for operators and ')'
   - 4 cases bnta h ....what to do when encounter ......1) ')'       2) '('    3) operators 4) operands

        -- operands encountered while reading given infix expression L to R  --> push in operands stack ( ye operands later evaluation k liye use honge ....isliye have to take care of char to integer conversion)
        -- '(' encountered --> push in operators stack
        -- ')' encountered --> 1) pop and keep on evaluating until we get '('           2) pop '(' too
        -- operators encountered --> jab tak operators stack empty nhi ho jata ya jab tak operators stack ke top pe '(' nhi dikh jata ya jab tab operators stack ke top par current char se lower precedence(matlab agar barabar precedence hua tab bhi evaluate krwana h) (of course precedence check krne k liye ek alag function likhna pdega ) ka character nhi aa jata.............tab tak purane operators ko evaluate krwate rho aur result ko operands stack me daalte rho (Note: even after processing whole infix expression, operator stack might not be empty (ex: 2+3*6) to phir se evaluate then push result in operand stack krna pdega and at last we'll find result in top of operand stack)....usi k baad current operator ko stack me daal sakte

       Note: poore code me operators stack me se hi bas pop krte h kabhi kabhi....operands me se pop bas evaluate krte samay krte h varna nhi


9) Queue to Stack adapter - push efficient.......Imp type
    -- queue use krke stack bnana h
    -- 2 queues use karna pdega...mainQ, helperQ
10) Queue to Stack adapter - pop efficient .............DIY
11) Stack to Queue - add efficient...........slightly different from previous adapter questions...references mainS aur helperS ka interchange nhi karna h 
12) Next Greater Element to/on the Right ...NGOR

        main: NGOR
        derivatives: NGOL, NSOR, NSOL

        stack contains --> ifwahnbfy --> indices for which ans has not been found yet

        OL --> traverse R to L.....every cell initiallised with -1
        OR --> traverse L to R......every cell initialised with n(=arr.length)

        NG --> arr[st.peek()] < arr[i]
        NS --> arr[st.peek()] > arr[i]

13) Stock Span....it's basically i - NGOL[i]
14) Largest Rectangle/Area in Histogram.....Refer Level Up notes instead
        -- Approach 1 --> NSOR, NSOL used..........mutiple pass solution
        -- Approach 2 --> 1 pass solution ......... NSOR jab hume milta h to uska hum kaise use krte they in previous solution?.....to ye socho aur NSOR ka code hi likho....NSOL will be whatever is below me in stack (magnitudewise) cuz mere (current ele) se <= ko to hum stack se pop krwa dete h in NSOR..............Caution: for some bars we might not find NSOR...pehle aise cases n se initialise krne par handle ho jate they ....par yahan na hi hum NSOR[] array use kar rhe...aur initially bhi hum stack me -1(cuz we are storing NSOL actually in stack) daal rhe n nhi 
  
        -- T. C of Approach 1, 2 are same but approach 2 does it in less passes of given input array

15) Sliding Window Maximum.....last NGOR within window is the maximum for that position of window....There are several other solutions - 1 using deque, and 1 using PriorityQueue as well but don't bother about them
16) Merge Overlapping Intervals.....sort the (start, end) pairs. Obviously only adjacent ones can overlap. But someone can overlap with the result of the previous overlap as well like candy crush game. so basically we need to remember order. So we use stack. Push the smallest pair in the stack initially. If the next/current/incoming pair begins after whatever is on the top of stack has ended, then obviously no overlap else overlap. In case of overlap merge. This can be done by correcting the ending time of the top of stack pair with the max of the 2 ending times which we are compairing
17) Smallest Number Following Pattern ......... Very Unique....Might not remember
     
     sabse chota no when we use less numerical magnitude numbers at the most significant bits
     
     so let's assume that there are only i's...so the numbers will look something like 123456......
     i) we have to remember the last number so that we can know the next number 

    But now if we get 'd' we have to decrease the number.....so knowing just the last number is enough
    But what if there are multiple d's .....so we should remember previous numbers as well
    so basically we have to remember whichever order we have followed so far....so we can use stack


    Observation through dry run on multiple examples --> smallest number tabhi aaega pattern follow karte hue jab hum D ke sequence k around filling Right to Left kare and not the other way round
    
   Solution --> i) stack me push aur ii) number increment to  humesha karna h chahe D aaye ya I ( number 1 se start karna pdega cuz MSB me less and less magnitude chhaiye)
                    par jab I aaye to stack empty bhi karna hoga kyunki ho sakta h I ke baad phir se D ka sequence aane lage in whic case we might require opposite ordering from R to L. Therefore stack as LIFO
   Caution...Edge case --> only 'i' or only 'd' as string imagine krke dekho

18) Min Stack - min in O(1) time......apart from normal stack (kyunki baki functions abhi bhi btana h and that too in O(1) time), 1more stack to store just mins .........EASY
19) Min Stack - min in O(1) time and O(1) space.....NOT STRAIGHTFORWARD....problem 18 me hum sare min values yaad rakh rhe they in a stack....abhi O(1) space me problem (problem is..O(1) time me min btana h) solve karna h matlab stack nhi use kar sakte...stack nhi use karna h aur sare previous min values bhi yaad rakhne h par kaise...min to har incoming element k sath change nhi hoga...to kyun nahin 
       
      - use a variable 'min' instead of stack                                        
      - just remember the points of changes in min value. How?
      - instead of incoming element (V) instead of V we always store (V + (V-M)) in stack when V is < M(current min)
      - how we will be able to identify that at which places we have not actually stored V ,......for such places element in stack will be < M else not
      - Caution: V ke jagah V + (negative no) store kar rhe to overflow ka issue aa sakta h. Thus have to use long type and it's wrapper class Long........       .intValue() to convert Long to int.....leetcode 155

20) Two stacks in same array.....tos1 = -1, tos2 = n initially


Linked List ( TODO: Go through Level up first then Foundation and then edit this .txt file...with exactly what needs to be remembered from LL in 1 place...do not segregate into Foundation LL and Level Up LL)
--------------
Advantage : to access non-contiguous locations in fragmented memory LL was introduced. Being able to access such locations is the advantage of LL
Disadvantage over array : i) extra memory required to store address................ ii) to get to any node have to travel through other nodes

removeLast() ....O(n)
removeFirst().....O(1)
addFirst()...........O(1)
addLast()...........O(1)


most common edge case ---> to be solved even before starting logic of problem........what if 0 child , what if 1 child

1)mid of LL....slow, fast pointer
   -- when even number of nodes and 
         - we want left node as mid.......stopping condition of loop.....fast.next != null && fast.next.next != null
         - we want right node as mid.......stopping condition of loop.....fast != null && fast.next != null      
         - return slow
         - Try not to blindly memorise this....draw and code

2) Kth node from end of LL.....size() directly ya indirectly (khud se size implement nhi kr skte) use nhi kar sakte
    - create initial separation of k then move the pointers with same speed.....near, far pointer.....far ko null tak nhi pahunchne dena h (have to keep within LL).....therefor have to use far != tail.....cuz tail ka next null hota h
3) Merge two sorted LL
    - compare and put in "res LL".....O(n) space
    - O(1) space (No extra space) solution in Level Up
4) Odd Even LL 
    - collect odd nodes in a separate LL and even in separate LL then combine them.......also handle if all odd in input ....or all even in input.....O(n) space solution
    - O(1) space (No extra space) solution in Level Up
5) Reverse LL (Pointer Recursive)
6) Intersection Point of 2 LL.......using map is not allowed......like "Kth node from the end of LL" problem, we'll have to create initial separation of diff in LL size in the larger LL
7) Reverse nodes in group of K in LL  or K reverse in LL....O(1) no extra space solution in Level Up (In Lvel Up new object of LL is not created)
8) Reverse a LL (data iterative)...Imp
9) Reverse a LL (data recursive)...Imp
10) Is LL a palindrome....using recusrion like problem 9
11) Fold a LL
12) Add 2 LL.....Very Imp....DIY without seeing solution


Foundation 2
----------------

Generic Trees
------------------
not two child like Binary Tree but has..... ArrayList<Node> children

1) Construct Generic Tree from given input............stack to be used
        - input me -1 dikha matlab we've got all info about a node ( ==> we now know about all the children of a particular node).....so that node should be popped out of stack (stack contains all the nodes about whom we do not have all the information i.e nodes whose all children are not known yet)
        - aur agar -1 k alawa kuch aur dikha to? ....to push to karna hi h stack me par tree bnate hue chalna h....i.e mai kiska baccha hu uske children[] me khudko add kar lena h before pushing in stack.............mai kiska baccha hu ye kaise pta chalega? mere se just pehle jo stack me hoga wo hoga mera baap ...kyu? cuz we are give preorder traversal of a GT ..which is N then L child then R child 
2) Height of GT.....max among height of all child + 1.......when we are talking in terms of edges(which is default) return -1 in base case or initialise with -1
3)Level Order Traversal of GT.....queue to be used....RPA....remove, print, add
4) Level Order - linewise  ( each level in new line) 
    i) Solution1 ......2 queues....1 queue for current level, 2nd queue for nextLevel ....when mainQ is finished transfer the reference of childQ in mainQ
    ii) Solution 2.......null marker after every child of all the members of current level are pushed.....iski implemetation error prone h
    iii) Solution 3.......most used.....remove from queue till levelSize becomes 0 then newline then ove to next level
    iv) Solution 4........store each child with its level....when the popped level is greater than the ongoing level we come to know that we have now entered next level
5) Level Order - Zigzag
    i) Solution 1....2 stacks + level variable
    ii) Solution 2.....1 stack + 1 queue + level variable

    matlab to bas 1 stack se hi h jisse order reverse ho jaye

6) Remove leaves in a GT
      - should remove from arraylist always from Right
      - ask first isLeaf()? to each node...if yes then remove it..................only then call the recursive function on each child
        Caution: can't call recursive call first on each child then ask each node that isLeaf()...........cuz in that case removing of child leaves might make parent a leaf which will get removed as now it has also become leaf and so on  the tree will become empty 
7) Linearize a GT...........DIY
     - breaks links of children last .....cuz removal from last of arrayList does not create any problem
     - Caution....Imp...have to run the loop for node.children.size() > 1 and not node.children.size() != 1  ...............  cuz we have run the loop for nodes with non-zero number of children and until the count becomes one....but node.children.size() != 1 allows the loop to be run even for leaf nodes which have 0 children

     - if faith is child ko linearise krke tail bhi bta  de then it would be an efficient approcah....as 1 loop will not be wasted in finding tail
8) Distance between nodes.....DIY..............note required nodeToRoot() required........(rootToNode() might also work....need to verify though)
9) Are GTs mirror in shape(not datawise)? ........DIY
10) Is GT symmetric /foldable?
    - In other words, they are asking ..... is the given GT mirror image of itself?
11) Predecessor and Successor of given node in preorder traversal............Very Imp
    - have to find out both pre and succ in 1 pass itself
    - have to maintain a variable 'state'
    - next call krne se pehle predecessor ko update karna h........Note: ek child se dusre child k taraf jate waqt predecessor ko nhi update karna h.........predecessor to be updated in "Node Pre" not in "Edge Pre"
    - state 0 to state 1 --> matlab data mil chuka h aur isliye ab further traversal me predecessor update nhi karna....to further traversal karna hi kyu h? kyunki successor pta lgane k liye aage explore karna hi pdega...hum future nhi dekh sakte
    - state 1 to state 2 --> aur ek baar successor mil jaye to 'successor' ko bhi update nhi karna h in further traversals ..........Note: this is in addition to "predecessor ko bhi nhi update karna h" 

    - Caution: agar tree me data ho hi nhi to we might end up informing wrong predecessor....Edge Case.....han par successor me kuch galat nhi hoga....kyunki successor update hi nhi ho paya hoga
12) Ceil --> smallest among larger
      Floor --> largest among smaller
13) Diameter of GT....Imp
     - koi bhi node se 2 chiz return krwao...diameter across that node, height of that node
     - height of that node is required to calculate diameter across its parent
     - kyunki diameter of a tree represented by say root....can be across root or can be within any of its subtree
     - Refer Level Up 3 ....Diameter Set

     TODO for future:  attach xerox of Level Up 3 version in  Foundation 2 notes

14) Kth largest......Very Imp.....DIY
     - equals floor of (K-1) th largest
     - 1st largest == floor of 0 th largest == Infinity
15) Node with maximum subtree sum ( there can be negative numbers as well stored in the tree)

16) Iterative preorder and postorder traversal ( this trick can also be used for inorder) (this trick can also be used for BTs) 
      - 'state' variable used
      - stack has <- - elements which have not been explored completely yet
      - state = -1 (i.e if we found state = -1 in tos) => call to 0th child has not been made => pre area ....increment state to 0 so that 0th child can be called in next iteration
      - state = n ( n == number of children of the node in tos) ==> all the children have been explored => post area => time to pop
      - state = x in between [1, n-1] ==> call xth child in next iteration.....increment state to (x+1) so that (x+1) th child can be called in next iteration

17) Iterable and Iterator interfaces
     - both are interfaces
     - class which implements Iterable has to implement Iterator<Integer> iterator() function... the implementation should contain an object of a class which has implemented Iterator interface
     - class which implements Iterator has to implement hasNext() and next()


Binary Trees
----------------
possible edge cases ---> 0 child, 1 child (only L child, only R child), 2 child (both L, R child)...........2 child is the main problem and not the edge case

GT me for(Node child: node.children) se null handle ho jata h....BT me null ke liye if(node==null) {} wala check lgana pdta h

Whenever we want more than 1 information from any node we have 2 options.....i) club the multiple information into a class and return that from every node or ii) return the info which is required to calculate the answer for parent and keep other info as static variables which can be changed by every node

1) Construct BT from given input
    - for GT we have arraylist of children which is dynamic, so while processing input for GT we just need to know when the children list of a particular node has ended. That's why '-1' marker in input
    - But for BT we do not have a list. Instead we have 2 nodes reference holders - L child and R child. So while processing input we need to know whether the node we are considering is the L child or the R child of the parent node
    - So in the input for constructing BT we use null for a non-existent child (it can be L or R child....if it is both then we use "null null" in input)...we'll always expect the first entry to be L child and next entry to be R child

    - to construct a BT from the input format described above, we use 'state' .....same logic as in iterative preorder of GT
    - state = 1 => next i/p is the L child of the node on tos(top of stack)
    - state = 2 => R child
    - state > 2 => both child of current node have already been plugged. Therefore time to pop the current node out of stack

2) Height of a BT.......when we are talking in terms of edges(which is default) return -1 in base case......height of leaf = 0 => height of null = -1
3) Iterative Pre, In, Post order traversal in BT (Note: Iterative not recursive)
    - on lines of iterative preorder, postorder traversal in a GT but not exactly same
    - here we have to check if L/R child exists in input only then push it in stack
    TODO: play around with slightly different approaches....Refer notes
4) Print K distance away......very Imp.........DIY
    -  this k distance can be k directly below me or .......1 up then k-1 down or......2 up then k-2 down.....up up up kab tak? all the way to root.......So first we need to find nodeToRootPath
    - traverse on nodeToRootPath[] and call recursive function on each of the node in it
    -                   A
                     /      \
                    /        \
                   /          \
                  C            B
                 
      Let's say we want to find 3 distance away from B.... 1 up to A then 2 down can be 1 way.... now when we go 2 down from A obviously we don't want to go towards B...cuz going 2 down from A towards B would be an equivalent of 1 down from B but we wanted 3 away from B
   - So we should mark B as 'blocker' node when we try to go down from A through initial recursive call.....when blocker node is encountered in our way down we should just return

5) Transform back from a left cloned tree .....DIY
6) largest BST subtree


Binary Search Trees
-------------------------
Structure based algos like size(), sum(), height(), diameter(), display() are same in BT and BST
But data based algos like max(), min(), find() are efficient in BST as compared to BT

BST --> O(log n)
BT --> O(n)

Inorder traversal of BST gives ascending order

1) Construct BST from given input
   - sort the input array if not already sorted
   - divide and conquer like mergesort (i.e divide in 2 almost equal halves....middle node is separate from these 2 halves) to get a balanced BST (whose height difference of left and right child is not more than 1)
   - currentNode.left = left recursive call
     currentNode.right = right recursive call
2) Remove nodes from BST (Recursive)
   - 4 cases, when the node to be removed is a .... i) 0 child node or ......ii) 1 child (L) node or.......iii) 1 child (R) node.....or iv) 2 child node (trickiest)
   - when 2 child node is to be removed, simply removing it will break the tree .....so it needs to be replaced with some other node....it can be replaced with either max of left subtree or min of right subtree....and then do not forget to remove the chosen max/min from left/right subtree respectively....and that will not be a problem as max/min can only be found at leaf nodes  

   - Recursive solution takes recursive space, iterative solution will take no extra space i.e it'll take O(1) space....That's why have attached iterative solution in Foundation 2 notes for add, delete in BST.....Iterative solution seems error prone...but try once w/o looking
   - BST problems should always be done iteratively.....Level Up 2...Tree....BST Set.....LCA in BST
3) Replace with sum of larger.... Imp....DIY...in both ways....LNR and RNL as well
                        A
                     /      \
                    /        \
                   /          \
                  C            B

    - For C --> A+ B is larger
      For A --> B is larger
4) LCA  in a BST
    - LCA in a BT --> O(n) space + recursive space (nodeToRootPath[] required)
    - LCA in a BST --> O(1) space + recursive space
5) Print in range
6) 2 Sum BST....Very Imp....O(h) == O(log n) for a balanced BT
    - we want answer pairs in increasing order. Therefore inorder traversal of BST (Any node cannot be used as both the elements of the pair)

    - 3 approaches ............   Approach 1 has better S.C.  ................   Approach 2 has better T.C  ..........    Approach 3 --> best of both worlds...approach 1,2..........while talking about S.C. we are not including the recursive stack space required for solving the main problem, we are just talking about how much extra space is required
    - Approach 1          T.C.: O(nh),      S.C.: O(h)
         - traverse all nodes, at each node find() the complement in BST...........complement = targetSum - currentNode.data........T.C. of find() in BST is O(h) == O(log n)
    - Approach 2          T.C.: O(n),        S.C.: O(n)
         - make an arrayList by traversing all of BST....then the problem reduces to 2 Sum problem on an array which can be solved using 2 pointers (left, right)
    - Approach 3          T.C.: O(n),        S.C.: O(h) ..............Just like Approach 2 but we just avoided storing in arrayList.....next element on demand.....streaming
         - left pointer can be obtained by InorderBSTIterator, right pointer can be obtained by ReverseInorderBSTIterator......cannot use recursive stack for iterator, need manual stack ( a data structure created in heap which could maintain state till when iterator is called the next time) so that it can be controlled.....use 'state' variable to code iterative inorder traversal (Refer Generic Trees section of Foundation 2)
         - If we use morris traversal to code iterator then we can reduce the S.C. to O(1) .......... Level Up 2 - Tree - Traversal Set - leetcode 173 Binary Search Tree Iterator
          

HashMaps and Heaps
----------------------------
a particular data structure is unordered ==> the order of insertion is not the same as order of storing

Inbuilt HashMap functions --> getOrDefault(key, defaultValue), putIfAbsent()

Heap 
   - PriorityQueue<Integer>pq = new PriorityQueue<>(); // min heap
   - PriorityQueue<Integer>pq = new PriorityQueue<>(Collections.reverseOrder()); // max heap 
     Alternatively for max heap
       -  PriorityQueue<Integer>pq = new PriorityQueue<>( (a,b) -> {
                return b-a;
          });
   - add(), remove() from heap --> O(log n)     peek() --> O(1)

   - HeapSort (add 1 by 1 in heap then remove 1 by 1 to get sorted order) --> T.C.: O(nlog n)          S.C.: O(n) ... There is an inplace version too // TODO: write more about the inplace version
    
1) k largest elements
   - Approach 1: using max heap.....O( (n+k) log n)
        - insert all elements in heap O(nlog n) time  then removal of k elements from heap in O(klog n) time
   - Approach 2: using min heap......O( (n+k) log k) .... better approach as k <= n
        - at any point contains the <=k largest elements found yet.........so initially we push k elements in the heap in O(klog k) time....now when the (k+1) th element arrives and if it is bigger than the current min in the heap, since the heap can only contain <=k elements ...min has to be removed and then replaced with the incoming element..and since we are removing min, we can say heap will contain "largest" elements at any point of time....Similarly we have to push remaining elements in the heap.....so total time complexity of pushing n elements in a heap of size k will be O(n log k)
        - now when all the elements are pushed in heap once...heap will contain the final k largest elements......the simulataneous removal of k largest elements from heap in O(klog k) time
2) Sort k nearly sorted array ..... every element of the array is at max displaced k spots left or right to its position in the sorted array
   - Approach 1: sort the array in O(nlog n) time...Note we did not use the fact that "at max k displaced"
   - Approach 2: using min heap O(n log k)  .... There will be <= (k+1) elements in the heap at any point of time
        - In sorted array min most element will be at 0th index and since it cannot be displaced on left, (no space...no valid array index on left) it can only be displaced upto index (k+0) on the right....so if we consider (k+1) elements from index 0 to index k, we'll definitely get the min element ...so heap of size (k+1) is enough... once we remove an element from heap to get current min only then we should add any further element in the heap...since the number of element in the heap should not exceed (k+1) 
        - add first then remove from heap is also ok but that'll just increase heap size which is not really needed .... kyunki heap me agar zaroort se zyada elements hi rakhna hota to n element hi kyu nhi rakh liye
3) Longest consecutive sequence of elements (like 5,6,7,8..... these can occur in any order and at any index which need necessarily be continuous indexes)   // TODO: think whether this should be in this list or is it too easy
   - either need to check ki previous element h ki nhi or need to check ki next element h ki nhi in the given sequence ...this search needs to be in as in time as possible.... therefore store every element in HashMap
   - we also need to print the sequence itself at the end... so need to know the starting or ending point of the LConsecutiveSequence (along with the size of the sequence of course) ...... therefore also store a marker in hashmap corresponding to every element indicating whether it is the starting/ending element or not
   - Algo:
        - 1. for every element in hashmap which is a starting/ending point, check if prev/next element exists....if it does current element is not the starting/ending point....mark for current element accordingly
        - 2. now for every element in hashmap which is still a starting point (an actual one not an assumed one) ..... count how many elements are present in sequence and find the longest such sequence

4) Implementation of PriorityQueue using heap .... Imp
   - Most important part: 
       i) with what parameters upHeapify(), downHeapify() are called for the first time
      ii) understanding and implementation of upHeapify, downHeapify
   - add(), remove() ... O(log n) ..... why so? cuz we always maintain a complete (balanced) heap .... and add/remove operations on a balanced tree are O(log n) .. like AVL(balanced BST) ...cuz only for balanced tree height of tree , h = log n  (complete --> all of previous h-1 levels are completely filled, and all levels are strictly filled from L to R. In other words there can be no R child if any L child is skipped) (balanced --> difference between height of left,right child subtrees is not more than 1) (a complete tree is always a balanced tree)
   - peek() ...O(1)
   - heap should be implemented using ArrayList and not using a BT (heap is not stored but visualised as a BT) cuz   
        i)  since we have to maintain a complete tree therefore to find out where to add() we need to do levelOrderTraversal which is O(n)
        ii) heap creation requires a upHeapify internal functionality which is movement from child to parent ...... which is not easy in a BT
   - add () --> uses upHeapify/downHeapify()
     remove() --> uses downHeapify

   - creation of heap (addition of n elements) can be done in 2 ways
       - online data (data coming 1 by 1...in other words streaming) ...each intermediate stage is heap ....uses upHeapify in add() ......O(nlog n) for creation of heap
       - complete data present initially .... first add all data in data structure then start doing downHeapify() from every node beginning with leaf nodes to make the data structure an actual heap ......O(n) for creation of heap

   - both upHeapify and downHeapify converts a non-heap to heap .... only their direction of movement is different

   - upHeapify (idx) - heapification might be required at parent too in addition to at idx (idx: current ....current ko parent se compare karna h isliye current paas kar rhe....subsequently pidx might become idx i.e upHeapify(idx) --> upHeapify(pidx)) 
       - idx = wo index jisko uske parent se compare karna h
       -  add() = add to last of arrayList then upHeapify(idx) .... why to last ? so that operation can be done in O(1) .... here idx = last index when initial call was made
       -  let's talk about minHeap....everything on left, right child subtrees must be greater than root
       -     A = 5
           /       \
         B=7     C = 3
      
         A is the parent of C not the root of heap

         let's say we have added at C (C is a leaf node) . If C > A then all is fine. Else if C <  A in this subtree, then C should be moved in place of A and A should be moved in place of C
         if we replace 3 with 5 then everything is fine as descendants should anyways be greater
         but initially everything below A was > 5, but now will those be > 3 when 3 is moved in place of A?? might not ..... so after swapping, subtree rooted at A  might need heapification ... i.e heapification might be needed at parent
         so we moved from child to parent ...... upHeapify(idx) --> upHeapify(pidx) 
         and so on we keep on moving up the tree ensuring everything below the checked node is a heap

   - downHeapify (0)  - heapification might be required at child too i.e downHeapify(0) --> downHeapify(childIdx)
       - remove() --> highest priority element is the only accessible element in the heap....so now when it needs to be removed, removing from beginning of arraylist will be O(n) due to shifting whereas removing from last of arrayList is O(1). 
       - For this 0th and last leaf node are swapped. which arises the need for downHeapification beginning at 0th 
         So after swapping , higher element is placed at 0th which might result in making the heap --> not heap ( parent might now no longer be the min among parent, left child, right child)
         To resolve this, parent is swapped with min child which might again end up in making that child subtree "not heap"
         and so on we keep on moving down the tree checking that all the way to below is a heap or not (Note: we are just comparing current node and its child for heap property....assuming ki child subtree to leap hoga hi...kyunki swap krne se pehle tak to sab kuch heap tha hi....isliye agar currentnode, L child, R child milke agar heap property satisfy krta h to we stop going down the tree)

   - upHeapify requires moving from a node to its parent
      - Formula for the same: pidx = (idx-1)/2
   - downHeapify requires moving from node to child
      - Formulae:
         i)  lc = 2 * pidx + 1
         ii) rc = 2 * pidx + 2

   - Note: swapping k baad hi call hota h to upHeapify or downHeapify ... not talking about initial call.....talking about recursive call

5) Median Priority Queue ... instead of max/min the heap should return median (middle element) in current sorted array in O(1) time 
   - PQ can only be min/max heap....we have to somehow adapt MPQ from a PQ
   - Internally MPQ for user = PQ1(max) + PQ2(min) ..... if MPQ = 10, 20, 30, 40, 50, 60 then PQ1 = 10, 20, 30  and PQ2 = 40, 50, 60
   - When we have to add() in MPQ how would we know whether internally we have to add in PQ1 or PQ2 ? if the incoming element is greater than peek of PQ2, then we add that element in PQ2 else PQ1
   - If we follow above we'll end up adding all elements in PQ1 itself and none in PQ2 cuz initially both of PQ1, PQ2 are empty and above comparison can only be done when PQ2 is non-empty
   - Also the size of PQ1, PQ2 should be more or less the same so that we can get median and not some random element at root of the heap
   - So whenever the size difference of PQ1, PQ2 becomes > 1, we shift 1 element between them to reduce the difference ... Imp point // easy to miss

6) Comparable vs Comparator
   - both are interfaces
   - if a class implements Comparable<T> , it has to implement the compareTo(T other) function
   - if a class implements Comparator<T> it has to implement the compare(T child, T parent) function
   - For min heap, compareTo(T other) should be implemented like below
     int compareTo (T other) {
           return this.x - other.x;  // x is a member of T class
     }
   - For max heap, compareTo(T other) should be implemented like below
     int compareTo (T other) {
           return other.x - this.x;  // x is a member of T class
     }
   - For implementing Comparator<T> , compare() should be implemented like below
     int compare(T child, T parent) {
         return child.x - parent.x;
    }
    - When we don't know that on which basis to compare any two objects, we keep several Comparators prepared. Each comparator does comparison on basis of 1 particular thing
    - How to use comparator??
        class StudentWeightComparator implements Comparator<Student> {
              int compare(Student s1, Student s2) {
                    return s1.wt - s2.wt; 
              }
        }
        class StudentHeightComparator implements Comparator<Student> {
              int compare(Student s1, Student s2) {
                    return s1.ht - s2.ht; 
              }
        }

         PriorityQueue<Student> pq = new PriorityQueue<>(new StudentWeightComparator());

7) Merge K sorted lists
   - most efficient O(Nlog K) approach using heap
8) Implementation of HashMap
   - HashMap --> array of LLs (like a graph, only difference being presence of a loading factor λ)
   - each cell of the above array is called a bucket
   - each node in the LL is a <key, value> pair
   - search in HM ≡ search in a specific bucket in HM.... put in HM ≡ put in a specificbucket in HM....similarly for other operations on HM
   - and time complexity for any operation on HM ≡ time complexity for that operation on 1 single bucket = O(λ) where λ = number of elements in HM (n) / number of buckets in HM or cell in array (N) = n/ N
   - we never let λ cross a particular value (threshold)....so we can say O(λ) ≡ O(constant) or O(1)
   - so average T.C. of any HM operation is O(1) but worst case is still O(n) ..... all elements of HM in 1 single bucket
   - How do we ensure λ stays under a threshhold (k) ? When λ becomes > k (why will λ change in the first place? with each insertion in HM, n increases but N doesn't change so λ increases) , we double the number of buckets and do reshuffling. This is called rehashing()......is a costly operation but its frequency decreases with each time λ crosses k....our sacrifice for a O(const) T.C.
   - How do we know which element should be placed/searched in which bucket? hashFunction(key) which returns bucketIndex
   - 1 way of implemetation of hashFunction() can be as follows
     int hashFunction(K key) {
        return Math.abs(ket.hashCode()) % buckets.length;
        
        // key.hashCode() not hashCode(key)
        // hashCode() can return -ve integer as well
    }




continue studying from.........
30 turns per completely free full day......speed
roughly 730 turns (Foundation 1,2 + Level Up 1,2,3,4)

obviously full free day to phir nhi milega
therefore for revising foundaton 1,2 + level Up 1,2,3,4 ---> 730/15 = 49 days required.....roughly 2 months